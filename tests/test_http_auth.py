# -*- coding: UTF-8 -*-
"""
Suite(s) of test for the http_auth.py module
"""
import os
import time
import unittest
from unittest.mock import patch, MagicMock

import jwt
import ujson
from flask import Flask

from vlab_api_common import http_auth, flask_common


class SomeView(flask_common.BaseView):
    """So we can test logic tied to Flask"""
    route_base = '/test'

    @http_auth.requires(verify=False, version=2)
    def get(self, *args, **kwargs):
        return 'woot', 200

    @http_auth.requires(verify=True, version=2)
    def put(self, *args, **kwargs):
        return 'woot', 200

    @http_auth.requires(verify=False, version=1)
    def post(self, *args, **kwargs):
        return 'woot', 200


class TestRequires(unittest.TestCase):
    """A suite of test cases for functions in the ``http_auth`` module"""
    @classmethod
    def setUp(cls):
        """Runs before every test case"""
        app = Flask('requires')
        SomeView.register(app)
        app.config['TESTING'] = True
        cls.app = app.test_client()
        cls.token = http_auth.generate_v2_test_token(username='bob')

    def test_ok(self):
        """``requires`` happy path test works"""
        resp = self.app.get('/test', headers={'X-Auth': self.token})

        self.assertEqual(resp.status_code, 200)

    @patch.object(http_auth, 'get_token_from_header')
    def test_expired(self, fake_get_token_from_header):
        """``requires`` handles expired auth tokens correctly"""
        fake_get_token_from_header.side_effect = http_auth.ExpiredSignatureError('testing')

        resp = self.app.get('/test', headers={'X-Auth': self.token})
        error_message = 'No Valid Session Found'

        self.assertEqual(resp.status_code, 401)
        self.assertEqual(resp.json['error'], error_message)

    @patch.object(http_auth, 'get_token_from_header')
    def test_invalid(self, fake_get_token_from_header):
        """``requires`` handles mangled/invalid auth tokens correctly"""
        fake_get_token_from_header.side_effect = http_auth.InvalidTokenError('testing')

        resp = self.app.get('/test', headers={'X-Auth': self.token})
        error_message = 'Invalid auth token supplied'

        self.assertEqual(resp.status_code, 401)
        self.assertEqual(resp.json['error'], error_message)

    @patch.object(http_auth, 'get_token_from_header')
    def test_value_error(self, fake_get_token_from_header):
        """``requires`` catches ValueError and returns HTTP 401"""
        fake_get_token_from_header.side_effect = ValueError('testing')

        resp = self.app.get('/test', headers={'X-Auth': self.token})
        error_message = 'testing'

        self.assertEqual(resp.status_code, 401)
        self.assertEqual(resp.json['error'], error_message)

    @patch.object(http_auth.requests, 'get')
    def test_verify_ok(self, fake_get):
        """``requires`` makes an HTTP call to verify the token when enabled"""
        fake_resp = MagicMock()
        fake_resp.ok = True
        fake_get.return_value = fake_resp

        resp = self.app.put('/test', headers={'X-Auth': self.token})

        self.assertEqual(resp.status_code, 200)
        self.assertTrue(fake_get.called)

    @patch.object(http_auth.requests, 'get')
    def test_verify_bad(self, fake_get):
        """``requires`` responses with the HTTP status code and message form the validation fa"""
        fake_resp = MagicMock()
        fake_resp.ok = False
        fake_resp.content = 'doh'
        fake_resp.status = 401
        fake_get.return_value = fake_resp

        resp = self.app.put('/test', headers={'X-Auth': self.token})

        self.assertEqual(resp.status_code, 401)
        self.assertTrue(fake_get.called)
        self.assertEqual(resp.data, b'doh')

    def test_no_acl(self):
        """``requires`` returns HTTP 403 if a user is not allowed access"""
        resp = self.app.post('/test', headers={'X-Auth': self.token})
        msg = 'user bob does not have access'

        self.assertEqual(resp.status_code, 403)
        self.assertEqual(resp.json['error'], msg)

    def test_no_token(self):
        """``get_token_from_header`` raises ValueError when no auth token is supplied"""
        resp = resp = self.app.get('/test')
        msg = 'No auth token sent in HTTP header'

        self.assertEqual(resp.status_code, 401)
        self.assertEqual(resp.json['error'], msg)

    def test_bad_ip(self):
        """``get_token_from_header`` verifies the client IP"""
        resp = self.app.get('/test', headers={'X-Auth': self.token, 'X-Forwarded-For' : '1.2.3.4'})
        msg = 'Token generated by 127.0.0.1, but sent from 1.2.3.4'

        self.assertEqual(resp.status_code, 401)
        self.assertEqual(resp.json['error'], msg)


class TestAclInToken1(unittest.TestCase):
    """Test cases for the ``acl_in_token`` function for version 1 of Maestro Auth Tokens

    This function contains the bulk of business logic for the 'deny' and 'requires'
    dectorators, and as such, it has a pile of tests around it. If you make changes
    to the function, and these test break, your changes are most likely not
    backwards compatable. In this senario, you should try to leverage the versioning
    of the Maestro Auth Token to both A) Meet your need to change things, and B)
    maintain backwards compatibility. In other words, assume these test are right,
    and your changes are bad, and get others to agree with you before changing
    these tests.
    """

    def setUp(self):
        # You should never have to change this -- if you need a different token,
        # make one in your specific test case
        self.token = {'version' : 1,
                      'username': 'bob',
                      'memberOf' : ['some-group', 'other-group']}

    def test_defaults_false(self):
        """When no parameters are set, `acl_in_token` returns False."""
        output = http_auth.acl_in_token(self.token)
        self.assertFalse(output)

    def test_version(self):
        """When the version param equals the token version, `acl_in_token` returns True.
        """
        output = http_auth.acl_in_token(self.token, version=1)
        self.assertTrue(output)

    def test_version_array(self):
        """When the version param is a List and the token contains an element
        within that list, `acl_in_token` returns True.
        """
        output = http_auth.acl_in_token(self.token, version=[1,2])
        self.assertTrue(output)

    def test_version_false(self):
        """When the version param does not equal the token version, `acl_in_token`
        returns False.
        """
        output = http_auth.acl_in_token(self.token, version=1000)
        self.assertFalse(output)

    def test_version_array_false(self):
        """When the version param is a List, the token DOESN'T contain an element
        within that list, `acl_in_token` returns False.
        """
        output = http_auth.acl_in_token(self.token, version=[1000,1001])
        self.assertFalse(output)

    def test_username(self):
        """When the username param equals the token username, `acl_in_token` returns True.
        """
        output = http_auth.acl_in_token(self.token, username='bob')
        self.assertTrue(output)

    def test_username_array(self):
        """When the username param is a List and the token contains an element
        within that list, `acl_in_token` returns True.
        """
        output = http_auth.acl_in_token(self.token, username=['bob'])
        self.assertTrue(output)

    def test_username_false(self):
        """When the username param does not equal the token username, `acl_in_token`
        returns False.
        """
        output = http_auth.acl_in_token(self.token, username='somePerson')
        self.assertFalse(output)

    def test_username_array_false(self):
        """When the username param is a List and the token DOESN"T contain an element
        within that list, `acl_in_token` returns False.
        """
        output = http_auth.acl_in_token(self.token, username=['peep-A', 'bro'])
        self.assertFalse(output)

    def test_memberOf(self):
        """When the memberOf param equals the token memberOf, `acl_in_token` returns True."""
        output = http_auth.acl_in_token(self.token, memberOf='some-group')
        self.assertTrue(output)

    def test_memberOf_array(self):
        """When the memberOf param is a List and the token contains an element
        within that list, `acl_in_token` returns True."""
        output = http_auth.acl_in_token(self.token, memberOf=['some-group', 'a-group-never-heard-of'])
        self.assertTrue(output)

    def test_memberOf_false(self):
        """When the memberOf param value is a string, and that value DOESN'T
        exist within the memberOf token array, `acl_in_token` return False.
        """
        output = http_auth.acl_in_token(self.token, memberOf='a-group-never-heard-of')
        self.assertFalse(output)

    def test_memberOf_array_false(self):
        """When the memberOf param value is a List, and NONE of those values
        exist within the memberOf token array, `acl_in_token` returns False.
        """
        output = http_auth.acl_in_token(self.token, memberOf=['a-group-never-heard-of', 'some-other-crazy-group'])
        self.assertFalse(output)


class TestGenerateTestToken(unittest.TestCase):
    """A suite of test cases for the `generate_test_token` function"""


    def test_basic_usage(self):
        """Verifies that `generate_test_token` returns an expected token"""
        token = http_auth.generate_test_token()

        self.assertTrue(isinstance(token, bytes))

    def test_v2_token(self):
        """Verifies that ``generate_v2_test_token`` returns an expected token"""
        token = http_auth.generate_v2_test_token()

        self.assertTrue(isinstance(token, bytes))


if __name__ == '__main__':
    unittest.main()
